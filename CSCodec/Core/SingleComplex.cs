using System;
using System.Collections.Generic;
using System.Numerics;
using System.Text;

namespace CSCodec.Core
{
	/// <summary>
	/// <see cref="Complex"/> like structure based on <see cref="float"/>
	/// </summary>
	public readonly partial struct SingleComplex : IEquatable<SingleComplex>, IFormattable
	{
		private readonly Vector2 value;

		//TODO: functions compatible to Complex

		/// <summary>
		/// Gets the real part of this instance.
		/// </summary>
		/// <value>
		/// The real part.
		/// </value>
		public float Real => value.X;

		/// <summary>
		/// Gets the imaginary part of this instance.
		/// </summary>
		/// <value>
		/// The imaginary part.
		/// </value>
		public float Imaginary => value.Y;

		/// <summary>
		/// Gets the magnitude of this instance.
		/// </summary>
		/// <value>
		/// The magnitude of this instance.
		/// </value>
		public float Magnitude => value.Length();

		/// <summary>
		/// Gets the phase of this instance.
		/// </summary>
		/// <value>
		/// The phase of this instance.
		/// </value>
		public float Phase => (float)Math.Atan2(value.Y, value.X);

		/// <summary>
		/// Initializes a new instance of the <see cref="SingleComplex"/> struct.
		/// </summary>
		/// <param name="real">The real part.</param>
		/// <param name="imaginary">The imaginary part.</param>
		public SingleComplex(float real, float imaginary)
		{
			value = new Vector2(real, imaginary);
		}

		/// <summary>
		/// Initializes a new instance of the <see cref="SingleComplex"/> struct.
		/// </summary>
		/// <param name="value">The value vector X=Real, Y=Imaginary.</param>
		public SingleComplex(Vector2 value)
		{
			this.value = value;
		}

		#region Constants and readonly fields

		/// <summary>
		/// The log 10 inv
		/// </summary>
		/// <autogeneratedoc />
		private const float LOG_10_INV = 0.43429448190325f;

		/// <summary>
		/// Returns a new Complex instance with a real number equal to zero and an imaginary number equal to zero.
		/// </summary>
		public static readonly SingleComplex Zero = new SingleComplex(0.0f, 0.0f);

		/// <summary>
		/// Returns a new Complex instance with a real number equal to one and an imaginary number equal to zero.
		/// </summary>
		public static readonly SingleComplex One = new SingleComplex(1.0f, 0.0f);

		/// <summary>
		/// Returns a new Complex instance with a real number equal to zero and an imaginary number equal to one.
		/// </summary>
		public static readonly SingleComplex ImaginaryOne = new SingleComplex(0.0f, 1.0f);

		#endregion Constants and readonly fields

		#region Unary Arithmetics

		/// <summary>
		/// Returns the additive inverse of a specified complex number.
		/// </summary>
		/// <param name="value">The value to negate.</param>
		/// <returns>
		/// The result of the <see cref="Real"/> and <see cref="Imaginary"/> components of the value parameter multiplied by -1.
		/// </returns>
		public static SingleComplex operator -(SingleComplex value) => new SingleComplex(-value.value);

		#endregion Unary Arithmetics

		#region Binary Arithmetics

		/// <summary>
		/// Subtracts a complex number from another complex number.
		/// </summary>
		/// <param name="left">The value to subtract from (the minuend).</param>
		/// <param name="right">The value to subtract (the subtrahend).</param>
		/// <returns>
		/// The result of subtracting <paramref name="right"/> from <paramref name="left"/>.
		/// </returns>
		public static SingleComplex operator -(SingleComplex left, SingleComplex right) => new SingleComplex(left.value - right.value);

		/// <summary>
		/// Adds two complex numbers.
		/// </summary>
		/// <param name="left">The first value to add.</param>
		/// <param name="right">The second value to add.</param>
		/// <returns>
		/// The sum of <paramref name="left"/> and <paramref name="right"/>.
		/// </returns>
		public static SingleComplex operator +(SingleComplex left, SingleComplex right) => new SingleComplex(left.value + right.value);

		/// <summary>
		/// Multiplies two specified complex numbers.
		/// </summary>
		/// <param name="left">The first value to multiply.</param>
		/// <param name="right">The second value to multiply.</param>
		/// <returns>
		/// The product of <paramref name="left"/> and <paramref name="right"/>.
		/// </returns>
		public static SingleComplex operator *(SingleComplex left, SingleComplex right)
			=> new SingleComplex(left.Real * right.Real - left.Imaginary * right.Imaginary, left.Real * right.Imaginary + left.Imaginary * right.Real);

		/// <summary>
		/// Multiplies specified complex number with specified real number.
		/// </summary>
		/// <param name="left">The first value to multiply.</param>
		/// <param name="right">The second value to multiply.</param>
		/// <returns>
		/// The product of <paramref name="left"/> and <paramref name="right"/>.
		/// </returns>
		public static SingleComplex operator *(SingleComplex left, float right) => new SingleComplex(left.Real * right, left.Imaginary * right);

		/// <summary>
		/// Divides a specified complex number by another specified complex number.
		/// </summary>
		/// <param name="left">The value to be divided.</param>
		/// <param name="right">The value to divide by.</param>
		/// <returns>
		/// The result of dividing <paramref name="left"/> by <paramref name="right"/>.
		/// </returns>
		public static SingleComplex operator /(SingleComplex left, SingleComplex right)
		{
			var div = 1.0f / right.value.LengthSquared();
			return new SingleComplex(div * (left.Real * right.Real + left.Imaginary * right.Imaginary), div * (left.Imaginary * right.Real - left.Real * right.Imaginary));
		}

		#endregion Binary Arithmetics

		#region Equality

		/// <summary>
		/// Indicates whether the values of two specified <see cref="SingleComplex"/> objects are equal.
		/// </summary>
		/// <param name="complex1">The first <see cref="SingleComplex"/> to compare.</param>
		/// <param name="complex2">The second <see cref="SingleComplex"/> to compare.</param>
		/// <returns>
		///   <c>true</c> if the value of complex1 is the same as the value of complex2; otherwise, <c>false</c>.
		/// </returns>
		public static bool operator ==(SingleComplex complex1, SingleComplex complex2) => complex1.value == complex2.value;

		/// <summary>
		/// Indicates whether the values of two specified <see cref="SingleComplex"/> objects are not equal.
		/// </summary>
		/// <param name="complex1">The first <see cref="SingleComplex"/> to compare.</param>
		/// <param name="complex2">The second <see cref="SingleComplex"/> to compare.</param>
		/// <returns>
		///   <c>true</c> if complex1 and complex2 are not equal; otherwise, <c>false</c>.
		/// </returns>
		public static bool operator !=(SingleComplex complex1, SingleComplex complex2) => !(complex1 == complex2);

		/// <summary>
		/// Determines whether the specified <see cref="object" />, is equal to this instance.
		/// </summary>
		/// <param name="obj">The <see cref="object" /> to compare with this instance.</param>
		/// <returns>
		///   <c>true</c> if the specified <see cref="object" /> is equal to this instance; otherwise, <c>false</c>.
		/// </returns>
		public override bool Equals(object obj) => (obj is SingleComplex complex) && value.Equals(complex.value);

		/// <summary>
		/// Returns a hash code for this instance.
		/// </summary>
		/// <returns>
		/// A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table.
		/// </returns>
		public override int GetHashCode() => -1584136870 + value.GetHashCode();

		/// <summary>
		/// Indicates whether the current object is equal to another object of the same type.
		/// </summary>
		/// <param name="other">An object to compare with this object.</param>
		/// <returns>
		/// true if the current object is equal to the <paramref name="other">other</paramref> parameter; otherwise, false.
		/// </returns>
		public bool Equals(SingleComplex other)
		{
			return this == other;
		}

		#endregion Equality

		#region Formattablity

		/// <summary>
		/// Converts this instance to string.
		/// </summary>
		/// <param name="format">The format.</param>
		/// <param name="formatProvider">The format provider.</param>
		/// <returns>
		/// A <see cref="string" /> that represents this instance.
		/// </returns>
		public string ToString(string format, IFormatProvider formatProvider)
		{
			return value.ToString(format, formatProvider);
		}

		#endregion Formattablity

		#region Implicit Conversions

		/// <summary>
		/// Performs an implicit conversion from <see cref="SingleComplex"/> to <see cref="Complex"/>.
		/// </summary>
		/// <param name="value">The value to convert.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static implicit operator Complex(SingleComplex value) => new Complex(value.Real, value.Imaginary);

		/// <summary>
		/// Performs an implicit conversion from <see cref="float"/> to <see cref="SingleComplex"/>.
		/// </summary>
		/// <param name="value">The value.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static implicit operator SingleComplex(float value) => new SingleComplex(value, 0);

		#endregion Implicit Conversions

		#region Explicit Conversions

		/// <summary>
		/// Performs an explicit conversion from <see cref="Complex"/> to <see cref="SingleComplex"/>.
		/// </summary>
		/// <param name="value">The value.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SingleComplex(Complex value) => new SingleComplex((float)value.Real, (float)value.Imaginary);

		#endregion Explicit Conversions

		#region Functions

		/// <summary>
		/// Gets the absolute value (or magnitude) of a complex number.
		/// </summary>
		/// <param name="value">A complex number.</param>
		/// <returns>The absolute value of <paramref name="value"/>.</returns>
		public static float Abs(SingleComplex value) => value.value.Length();

		/// <summary>
		/// Computes the conjugate of a complex number and returns the result.
		/// </summary>
		/// <param name="value">A complex number.</param>
		/// <returns>The conjugate of <paramref name="value"/>.</returns>
		public static SingleComplex Conjugate(SingleComplex value) => new SingleComplex(value.Real, -value.Imaginary);

		/// <summary>
		/// Returns the multiplicative inverse of a complex number.
		/// </summary>
		/// <param name="value">A complex number.</param>
		/// <returns>The reciprocal of <paramref name="value"/>.</returns>
		public static SingleComplex Reciprocal(SingleComplex value)
		{
			if ((value.Real == 0) && (value.Imaginary == 0))
			{
				return Zero;
			}
			return One / value;
		}

		/// <summary>
		/// Adds two complex numbers and returns the result.
		/// </summary>
		/// <param name="left">The first value to add.</param>
		/// <param name="right">The second value to add.</param>
		/// <returns>
		/// The sum of <paramref name="left"/> and <paramref name="right"/>.
		/// </returns>
		public static SingleComplex Add(SingleComplex left, SingleComplex right) => left + right;

		/// <summary>
		/// Subtracts a complex number from another complex number and returns the result.
		/// </summary>
		/// <param name="left">The value to subtract from (the minuend).</param>
		/// <param name="right">The value to subtract (the subtrahend).</param>
		/// <returns>
		/// The result of subtracting <paramref name="right"/> from <paramref name="left"/>.
		/// </returns>
		public static SingleComplex Subtract(SingleComplex left, SingleComplex right) => left - right;

		/// <summary>
		/// Multiplies two specified complex numbers.
		/// </summary>
		/// <param name="left">The first value to multiply.</param>
		/// <param name="right">The second value to multiply.</param>
		/// <returns>
		/// The product of <paramref name="left"/> and <paramref name="right"/>.
		/// </returns>
		public static SingleComplex Multiply(SingleComplex left, SingleComplex right) => left * right;

		/// <summary>
		/// Divides a specified complex number by another specified complex number.
		/// </summary>
		/// <param name="left">The value to be divided.</param>
		/// <param name="right">The value to divide by.</param>
		/// <returns>
		/// The result of dividing <paramref name="left"/> by <paramref name="right"/>.
		/// </returns>
		public static SingleComplex Divide(SingleComplex left, SingleComplex right) => left / right;

		/// <summary>
		/// Returns the additive inverse of a specified complex number.
		/// </summary>
		/// <param name="value">The value to negate.</param>
		/// <returns>
		/// The result of the <see cref="Real"/> and <see cref="Imaginary"/> components of the value parameter multiplied by -1.
		/// </returns>
		public static SingleComplex Negate(SingleComplex value) => -value;

		/// <summary>
		/// Creates a complex number from a point's polar coordinates.
		/// </summary>
		/// <param name="magnitude">The magnitude, which is the distance from the origin (the intersection of the x-axis and the y-axis) to the number.</param>
		/// <param name="phase">The phase, which is the angle from the line to the horizontal axis, measured in radians.</param>
		/// <returns>A complex number.</returns>
		public static SingleComplex FromPolarCoordinates(double magnitude, double phase) => (SingleComplex)Complex.FromPolarCoordinates(magnitude, phase);

		/// <summary>
		/// Creates a complex number from a point's polar coordinates.
		/// </summary>
		/// <param name="magnitude">The magnitude, which is the distance from the origin (the intersection of the x-axis and the y-axis) to the number.</param>
		/// <param name="phase">The phase, which is the angle from the line to the horizontal axis, measured in radians.</param>
		/// <returns>A complex number.</returns>
		public static SingleComplex FromPolarCoordinates(float magnitude, float phase) => (SingleComplex)Complex.FromPolarCoordinates(magnitude, phase);

		/// <summary>
		/// Returns the square root of a specified complex number.
		/// </summary>
		/// <param name="value">A complex number.</param>
		/// <returns>The square root of <paramref name="value"/>.</returns>
		public static SingleComplex Sqrt(SingleComplex value) => (SingleComplex)Complex.Sqrt(value);

		#endregion Functions
	}
}
